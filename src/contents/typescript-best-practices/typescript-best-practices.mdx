export const metadata = {
  title: "TypeScript 베스트 프랙티스 2025",
  description: "실무에서 꼭 지켜야 할 TypeScript 코딩 규칙과 타입 안정성을 높이는 방법을 소개합니다.",
  date: "2025-12-11",
  author: "CLAVISHADE",
  tags: ["TypeScript", "Best Practices", "코딩 규칙"],
  published: true,
  thumbnail: '/blog/typescript-best-practices/thumbnail.webp',
};

TypeScript를 사용할 때 지켜야 할 베스트 프랙티스를 정리했습니다.

## Strict Mode 활성화

`tsconfig.json`에서 strict 모드를 반드시 활성화하세요:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

## any 타입 절대 금지

`any`는 TypeScript의 타입 시스템을 무력화합니다. 대신 `unknown`을 사용하세요:

```tsx
// 나쁜 예
function process(data: any) {
  return data.value;
}

// 좋은 예
function process(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: string }).value;
  }
  throw new Error('Invalid data');
}
```

## Interface vs Type

일반적으로 객체 타입은 `interface`, 유니온이나 유틸리티 타입은 `type`을 사용합니다:

```tsx
// Interface - 객체 구조
interface User {
  id: number;
  name: string;
  email: string;
}

// Type - 유니온, 유틸리티
type Status = 'pending' | 'success' | 'error';
type PartialUser = Partial<User>;
```

## 제네릭 활용

타입을 재사용 가능하게 만들기 위해 제네릭을 적극 활용하세요:

```tsx
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  const response = await fetch(url);
  return response.json();
}

// 사용
const users = await fetchData<User[]>('/api/users');
const user = await fetchData<User>('/api/users/1');
```

## Type Guards

런타임 타입 검사를 위해 Type Guard를 사용하세요:

```tsx
interface Cat {
  meow(): void;
}

interface Dog {
  bark(): void;
}

function isCat(animal: Cat | Dog): animal is Cat {
  return 'meow' in animal;
}

function makeSound(animal: Cat | Dog) {
  if (isCat(animal)) {
    animal.meow(); // TypeScript가 Cat임을 인식
  } else {
    animal.bark(); // TypeScript가 Dog임을 인식
  }
}
```

## Readonly와 Const Assertions

불변성을 표현하기 위해 `readonly`와 `as const`를 사용하세요:

```tsx
// Readonly
interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}

// Const Assertions
const colors = ['red', 'green', 'blue'] as const;
type Color = typeof colors[number]; // 'red' | 'green' | 'blue'
```

## 유틸리티 타입 활용

TypeScript 내장 유틸리티 타입을 적극 활용하세요:

```tsx
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

// Omit - 특정 필드 제외
type PublicUser = Omit<User, 'password'>;

// Pick - 특정 필드만 선택
type UserCredentials = Pick<User, 'email' | 'password'>;

// Partial - 모든 필드 선택적
type UserUpdate = Partial<User>;

// Required - 모든 필드 필수
type RequiredUser = Required<Partial<User>>;
```

## 결론

TypeScript의 타입 시스템을 최대한 활용하면 런타임 에러를 컴파일 타임에 잡을 수 있습니다. strict 모드와 any 금지는 필수입니다.
